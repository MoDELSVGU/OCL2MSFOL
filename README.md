# OCL2MSFOL
OCL2MSFOL is another implementation of mapping from Object Constraint Language (OCL) to Many-Sorted First-Order Logic (MS-FOL).

Based on [the work](https://software.imdea.org/~dania/papers/models2016.pdf) of Manuel Clavel and Carolina Dania at IMDEA Research Institute, Spain.

In principal, given
  * a data model D, written conforms to the syntax depicts [here](https://github.com/SE-at-VGU/SQLTranslator).
  * an OCL boolean expression q of D, in plaintext, written conforms to the syntax depicts [here](https://github.com/SE-at-VGU/JavaOCL).
  * (optional) a forth-logic value, either TRUE (by default), FALSE, NULL or INVALID.
OCL2MSFOL generates a Satisfiability Modulo Theory (SMT), comprises of:
  * functions, predicates that related to the data model.
  * functions, predicates that related to the given expression.

---
**Correctness**

Let D be the data model, O be D's object model, q be the OCL boolean expression of D.

Let Eval be the evaluation function of OCL, such that Eval(O,q) be the result of evalutation OCL expression q on object model O of D.

Let b be the logic value and OCL2MSFOL(D,q,b) = T, T be the theory that generated by the tool.

If SMT Solver runs T and returns UNSAT, then for all O of D, Eval(O,q) != b

---

We plan to implement it in an incremental way, i.e. we implement only the operator and iterator that we are using for writing our artifacts.

-----
Current OCL expression used (to be updated):
* TRUE
* caller = self
* caller.students->includes(self)
* Lecturer.allInstances()->forall(l|Student.allInstances()->includes(l.students))
* Lecturer.allInstances()->select(l|l = caller)->includes(self)
* Lecturer.allInstances()->forAll(l1|Lecturer.allInstances()->forAll(l2|l1.age = l2.age))
* Lecturer.allInstances()->forall(l|l!=caller implies l.age < caller.age)

Current operation must be implemented:
* Literal
* Variables
* Free Variables (to be extended)
* Equality, Less than
* allInstances
* Attribute
* Association-ends (many-to-many)
* includes, forall, select
